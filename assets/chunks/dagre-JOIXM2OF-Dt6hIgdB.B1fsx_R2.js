import{p as v,C as M,h as F,f as L,l as j,F as i,u as Y,G as H,c as Q,D as $,Q as q,M as z,a as D,b as K,i as U,J as V}from"./theme.F6PnGTkS.js";import{L as G}from"./graph-DwJ2fmlY.B9ZxJNjS.js";import{o as W}from"./layout-1c1sXetJ.tmmz0_op.js";import{E as S}from"./baseUniq-y2HM5nbD.Vs1g8xSB.js";import{a as Z}from"./clone-DJqr9BGE.CJYgbQh-.js";import{g as A}from"./basePickBy-zvqYOuXh.BrqSNkjb.js";import"./framework.B4DAyMYG.js";function X(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:_(e),edges:ee(e)};return S(e.graph())||(r.value=Z(e.graph())),r}function _(e){return A(e.nodes(),function(r){var n=e.node(r),d=e.parent(r),c={v:r};return S(n)||(c.value=n),S(d)||(c.parent=d),c})}function ee(e){return A(e.edges(),function(r){var n=e.edge(r),d={v:r.v,w:r.w};return S(r.name)||(d.name=r.name),S(n)||(d.value=n),d})}var l=new Map,N=new Map,k=new Map,ne=v(()=>{N.clear(),k.clear(),l.clear()},"clear"),I=v((e,r)=>{const n=N.get(r)||[];return i.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),re=v((e,r)=>{const n=N.get(r)||[];return i.info("Descendants of ",r," is ",n),i.info("Edge is ",e),e.v===r||e.w===r?!1:n?n.includes(e.v)||I(e.v,r)||I(e.w,r)||n.includes(e.w):(i.debug("Tilt, ",r,",not in descendants"),!1)},"edgeInCluster"),J=v((e,r,n,d)=>{i.warn("Copying children of ",e,"root",d,"data",r.node(e),d);const c=r.children(e)||[];e!==d&&c.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",c),c.forEach(s=>{if(r.children(s).length>0)J(s,r,n,d);else{const a=r.node(s);i.info("cp ",s," to ",d," with parent ",e),n.setNode(s,a),d!==r.parent(s)&&(i.warn("Setting parent",s,r.parent(s)),n.setParent(s,r.parent(s))),e!==d&&s!==e?(i.debug("Setting parent",s,e),n.setParent(s,e)):(i.info("In copy ",e,"root",d,"data",r.node(e),d),i.debug("Not Setting parent for node=",s,"cluster!==rootId",e!==d,"node!==clusterId",s!==e));const o=r.edges(s);i.debug("Copying Edges",o),o.forEach(u=>{i.info("Edge",u);const E=r.edge(u.v,u.w,u.name);i.info("Edge data",E,d);try{re(u,d)?(i.info("Copying as ",u.v,u.w,E,u.name),n.setEdge(u.v,u.w,E,u.name),i.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):i.info("Skipping copy of edge ",u.v,"-->",u.w," rootId: ",d," clusterId:",e)}catch(b){i.error(b)}})}i.debug("Removing node",s),r.removeNode(s)})},"copy"),P=v((e,r)=>{const n=r.children(e);let d=[...n];for(const c of n)k.set(c,e),d=[...d,...P(c,r)];return d},"extractDescendants"),te=v((e,r,n)=>{const d=e.edges().filter(o=>o.v===r||o.w===r),c=e.edges().filter(o=>o.v===n||o.w===n),s=d.map(o=>({v:o.v===r?n:o.v,w:o.w===r?r:o.w})),a=c.map(o=>({v:o.v,w:o.w}));return s.filter(o=>a.some(u=>o.v===u.v&&o.w===u.w))},"findCommonEdges"),x=v((e,r,n)=>{const d=r.children(e);if(i.trace("Searching children of id ",e,d),d.length<1)return e;let c;for(const s of d){const a=x(s,r,n),o=te(r,n,a);if(a)if(o.length>0)c=a;else return a}return c},"findNonClusterChild"),O=v(e=>!l.has(e)||!l.get(e).externalConnections?e:l.has(e)?l.get(e).id:e,"getAnchorId"),ie=v((e,r)=>{if(!e||r>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(i.warn("Cluster identified",n," Replacement id in edges: ",x(n,e,n)),N.set(n,P(n,e)),l.set(n,{id:x(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const d=e.children(n),c=e.edges();d.length>0?(i.debug("Cluster identified",n,N),c.forEach(s=>{const a=I(s.v,n),o=I(s.w,n);a^o&&(i.warn("Edge: ",s," leaves cluster ",n),i.warn("Descendants of XXX ",n,": ",N.get(n)),l.get(n).externalConnections=!0)})):i.debug("Not a cluster ",n,N)});for(let n of l.keys()){const d=l.get(n).id,c=e.parent(d);c!==n&&l.has(c)&&!l.get(c).externalConnections&&(l.get(n).id=c)}e.edges().forEach(function(n){const d=e.edge(n);i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let c=n.v,s=n.w;if(i.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(i.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),c=O(n.v),s=O(n.w),e.removeEdge(n.v,n.w,n.name),c!==n.v){const a=e.parent(c);l.get(a).externalConnections=!0,d.fromCluster=n.v}if(s!==n.w){const a=e.parent(s);l.get(a).externalConnections=!0,d.toCluster=n.w}i.warn("Fix Replacing with XXX",c,s,n.name),e.setEdge(c,s,d,n.name)}}),i.warn("Adjusted Graph",X(e)),B(e,0),i.trace(l)},"adjustClustersAndEdges"),B=v((e,r)=>{var c,s;if(i.warn("extractor - ",r,X(e),e.children("D")),r>10){i.error("Bailing out");return}let n=e.nodes(),d=!1;for(const a of n){const o=e.children(a);d=d||o.length>0}if(!d){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",n,r);for(const a of n)if(i.debug("Extracting node",a,l,l.has(a)&&!l.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",r),!l.has(a))i.debug("Not a cluster",a,r);else if(!l.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){i.warn("Cluster without external connections, without a parent and with children",a,r);let o=e.graph().rankdir==="TB"?"LR":"TB";(s=(c=l.get(a))==null?void 0:c.clusterData)!=null&&s.dir&&(o=l.get(a).clusterData.dir,i.warn("Fixing dir",l.get(a).clusterData.dir,o));const u=new G({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",X(e)),J(a,e,u,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:l.get(a).clusterData,label:l.get(a).label,graph:u}),i.warn("New graph after copy node: (",a,")",X(u)),i.debug("Old graph after copy",X(e))}else i.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!l.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),r),i.debug(l);n=e.nodes(),i.warn("New list of nodes",n);for(const a of n){const o=e.node(a);i.warn(" Now next level",a,o),o!=null&&o.clusterNode&&B(o.graph,r+1)}},"extractor"),T=v((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(d=>{const c=e.children(d),s=T(e,c);n=[...n,...s]}),n},"sorter"),ae=v(e=>T(e,e.children()),"sortNodesByHierarchy"),R=v(async(e,r,n,d,c,s)=>{i.warn("Graph in recursive render:XAX",X(r),c);const a=r.graph().rankdir;i.trace("Dir in recursive render - dir:",a);const o=e.insert("g").attr("class","root");r.nodes()?i.info("Recursive render XXX",r.nodes()):i.info("No nodes found for",r),r.edges().length>0&&i.info("Recursive edges",r.edge(r.edges()[0]));const u=o.insert("g").attr("class","clusters"),E=o.insert("g").attr("class","edgePaths"),b=o.insert("g").attr("class","edgeLabels"),h=o.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(g){const t=r.node(g);if(c!==void 0){const f=JSON.parse(JSON.stringify(c.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,f.height,`
Parent cluster`,c.height),r.setNode(c.id,f),r.parent(g)||(i.trace("Setting parent",g,c.id),r.setParent(g,c.id,f))}if(i.info("(Insert) Node XXX"+g+": "+JSON.stringify(r.node(g))),t==null?void 0:t.clusterNode){i.info("Cluster identified XBX",g,t.width,r.node(g));const{ranksep:f,nodesep:w}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:f+25,nodesep:w});const m=await R(h,t.graph,n,d,r.node(g),s),C=m.elem;H(t,C),t.diff=m.diff||0,i.info("New compound node after recursive render XAX",g,"width",t.width,"height",t.height),Q(C,t)}else r.children(g).length>0?(i.trace("Cluster - the non recursive path XBX",g,t.id,t,t.width,"Graph:",r),i.trace(x(t.id,r)),l.set(t.id,{id:x(t.id,r),node:t})):(i.trace("Node - the non recursive path XAX",g,h,r.node(g),a),await $(h,r.node(g),{config:s,dir:a}))})),await v(async()=>{const g=r.edges().map(async function(t){const f=r.edge(t.v,t.w,t.name);i.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),i.info("Fix",l,"ids:",t.v,t.w,"Translating: ",l.get(t.v),l.get(t.w)),await q(b,f)});await Promise.all(g)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(X(r))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),W(r),i.info("Graph after layout:",JSON.stringify(X(r)));let p=0,{subGraphTitleTotalMargin:y}=z(s);return await Promise.all(ae(r).map(async function(g){var f;const t=r.node(g);if(i.info("Position XBX => "+g+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=y,i.info("A tainted cluster node XBX1",g,t.id,t.width,t.height,t.x,t.y,r.parent(g)),l.get(t.id).node=t,D(t);else if(r.children(g).length>0){i.info("A pure cluster node XBX1",g,t.id,t.x,t.y,t.width,t.height,r.parent(g)),t.height+=y,r.node(t.parentId);const w=(t==null?void 0:t.padding)/2||0,m=((f=t==null?void 0:t.labelBBox)==null?void 0:f.height)||0,C=m-w||0;i.debug("OffsetY",C,"labelHeight",m,"halfPadding",w),await K(u,t),l.get(t.id).node=t}else{const w=r.node(t.parentId);t.y+=y/2,i.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",w,w==null?void 0:w.offsetY,t),D(t)}})),r.edges().forEach(function(g){const t=r.edge(g);i.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(t),t),t.points.forEach(C=>C.y+=y/2);const f=r.node(g.v);var w=r.node(g.w);const m=U(E,t,l,n,f,w,d);V(t,m)}),r.nodes().forEach(function(g){const t=r.node(g);i.info(g,t.type,t.diff),t.isGroup&&(p=t.diff)}),i.warn("Returning from recursive render XAX",o,p),{elem:o,diff:p}},"recursiveRender"),he=v(async(e,r)=>{var s,a,o,u,E,b;const n=new G({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((s=e.config)==null?void 0:s.nodeSpacing)||((o=(a=e.config)==null?void 0:a.flowchart)==null?void 0:o.nodeSpacing)||e.nodeSpacing,ranksep:((u=e.config)==null?void 0:u.rankSpacing)||((b=(E=e.config)==null?void 0:E.flowchart)==null?void 0:b.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),d=r.select("g");M(d,e.markers,e.type,e.diagramId),F(),L(),j(),ne(),e.nodes.forEach(h=>{n.setNode(h.id,{...h}),h.parentId&&n.setParent(h.id,h.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(h=>{if(h.start===h.end){const p=h.start,y=p+"---"+p+"---1",g=p+"---"+p+"---2",t=n.node(p);n.setNode(y,{domId:y,id:y,parentId:t.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(y,t.parentId),n.setNode(g,{domId:g,id:g,parentId:t.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(g,t.parentId);const f=structuredClone(h),w=structuredClone(h),m=structuredClone(h);f.label="",f.arrowTypeEnd="none",f.id=p+"-cyclic-special-1",w.arrowTypeStart="none",w.arrowTypeEnd="none",w.id=p+"-cyclic-special-mid",m.label="",t.isGroup&&(f.fromCluster=p,m.toCluster=p),m.id=p+"-cyclic-special-2",m.arrowTypeStart="none",n.setEdge(p,y,f,p+"-cyclic-special-0"),n.setEdge(y,g,w,p+"-cyclic-special-1"),n.setEdge(g,p,m,p+"-cyc<lic-special-2")}else n.setEdge(h.start,h.end,{...h},h.id)}),i.warn("Graph at first:",JSON.stringify(X(n))),ie(n),i.warn("Graph after XAX:",JSON.stringify(X(n)));const c=Y();await R(d,n,e.type,e.diagramId,void 0,c)},"render");export{he as render};
